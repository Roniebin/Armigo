import math
from math import pi
from random import uniform
from typing import Any, Dict,Tuple

import numpy as np
from panda_gym.envs.core import Task
from panda_gym.pybullet import PyBullet
from panda_gym.envs.robots.panda import Panda

class TargetObject:
    """
    TargetObject tracks the lifecycle of a target object (not a goal)
    """

    def __init__(
        self,
        id: str,
        name: str,
        shape: int,
        size: np.array,
        position: np.array,
        color: np.array,
        removed: bool = False,
    ):
        self.id = id
        self.name = name
        self.shape = shape
        self.size = size
        self.position = position
        self.color = color
        self.removed = removed
        
class Sorter(Task):
    def __init__(
        self,
        sim: PyBullet,
        robot: Panda,
        num_objects: int = 3,
        reward_type: str = "dense",
        distance_threshold: float = 0.05,
        obj_x_range: float = 0.2,
        obj_y_range: float = 0.6,
    ):
        super().__init__(sim)
        self.robot = robot
        self.score: float = 0.0
        self.num_objects: int = num_objects
        self.reward_type = reward_type
        self.distance_threshold = distance_threshold
        self.obj_x_range = obj_x_range
        self.obj_y_range = obj_y_range
        self.obj_range_low = np.array([-obj_x_range / 2, -obj_y_range / 2, 0])
        self.obj_range_high = np.array([obj_x_range / 2, obj_y_range / 2, 0])
        self.fixed_size = np.array([0.04, 0.04, 0.04])
        
        self.sim.create_plane(z_offset=-0.4)
        
        #!목표
        self.sorter_positions : Dict[str, np.array] = {}
        self.sorter_colors : Dict[str, np.array] = {}
        self.sorter_size = np.array([0.04, 0.04, 0.01])
        self._init_sorters()
        
        #!물체
        self.size_multiplier: Tuple[float, float] = (0.8, 1.2)
        self.goal_colors = [
            np.array([1.0, 0.0, 0.0, 1.0]),  # 빨강 (박스)
            np.array([0.0, 0.0, 1.0, 1.0]),  # 파랑 (실린더)
            np.array([0.0, 1.0, 0.0, 1.0])  # 초록 (스피어)
        ]# 각 물체의 색상
        self.goal: Dict[int, TargetObject] = {}
        
        # with self.sim.no_rendering():
        self._create_scene()
    
    #!목표 설정
    def _init_sorters(self):
        self.sorter_positions = {
            SORTING_ONE: np.array([0.2, -0.2, 0.01]),
            SORTING_TWO: np.array([0.2, 0, 0.01]),
            SORTING_THREE:  np.array([0.2, 0.2, 0.01])
        }
        self.sorter_colors = {
            SORTING_ONE: np.array([1.0, 0.0, 0.0, 0.4]),
            SORTING_TWO: np.array([0.0, 0.0, 1.0, 0.4]),
            SORTING_THREE:  np.array([0.0, 1.0, 0.0, 0.4])
        }
        self.sim.create_box(
            body_name=SORTING_ONE,
            half_extents=self.sorter_size,
            mass=0.0,
            ghost=True,
            position=self.sorter_positions[SORTING_ONE],
            rgba_color=self.sorter_colors[SORTING_ONE],
        )
        self.sim.create_box(
            body_name=SORTING_TWO,
            half_extents=self.sorter_size,
            mass=0.0,
            ghost=True,
            position=self.sorter_positions[SORTING_TWO],
            rgba_color=self.sorter_colors[SORTING_TWO],
        )
        self.sim.create_box(
            body_name=SORTING_THREE,
            half_extents=self.sorter_size,
            mass=0.0,
            ghost=True,
            position=self.sorter_positions[SORTING_THREE],
            rgba_color=self.sorter_colors[SORTING_THREE],
        )
        # Visualize the object range with a transparent box
        self.sim.create_box(
            body_name="range_visualization",
            half_extents=[self.obj_x_range / 2, self.obj_y_range / 2, 0.01],  # very thin box
            mass=0.0,
            position=[0, 0, 0.005],  # slightly above the plane to make it visible
            rgba_color=[0, 1, 1, 0.3],  # cyan and semi-transparent
            ghost=True 
        )
        
    def set_sorter_positions(self):
        for sorter in self.sorter_positions:
            self.sim.set_base_pose(
                sorter,
                position=self.sorter_positions[sorter],
                orientation=np.array([0.0, 0.0, 0.0, 1.0]),
            )
        
    #!물체 설정
    def setup_target_objects(self):
        base_size = 0.025
        # First, delete each object to cleanup
        self.delete_all_objects()
        
        for object in range(0, self.num_objects):
            while True:
                name = f"object_{object}"
                color = self.goal_colors[object]
                shape = SHAPES[object]
                position = self._random_position()
                
                if shape == CUBE:
                    x = base_size * uniform(
                        self.size_multiplier[0], self.size_multiplier[1]
                    )
                    y = base_size * uniform(
                        self.size_multiplier[0], self.size_multiplier[1]
                    )
                    z = base_size * uniform(
                        self.size_multiplier[0], self.size_multiplier[1]
                    )
                    size = np.array([x, y, z]).astype(np.float32)
                    self.sim.create_box(
                        body_name=name,
                        half_extents=np.array([x, y, z]),
                        mass=1.0, 
                        position=position, 
                        rgba_color=color
                    )
                elif shape == CYLINDER:
                    height = base_size * uniform(
                        self.size_multiplier[0], self.size_multiplier[1]
                    )
                    radius = base_size * uniform(
                        self.size_multiplier[0], self.size_multiplier[1]
                    )
                    size = np.array([height, radius, 0.0]).astype(np.float32)
                    self.sim.create_cylinder(
                        body_name=name,
                        radius=radius,
                        height=height,
                        mass=1.0,
                        position=position, 
                        rgba_color=color
                    )
                elif shape == SPHERE:
                    multiplier = uniform(
                        self.size_multiplier[0], self.size_multiplier[1]
                    )
                    self.sim.create_sphere(
                        body_name=name,
                        radius=base_size * multiplier,
                        mass=1.0,
                        position=position, 
                        rgba_color=color
                    )
        
                id = self.sim._bodies_idx[name]

                # Now ensure that the shape created does not
                # intersect any of the existing shapes
                collisions = False
                # If this is the first, we're good; move on
                if len(self.goal) <= 0:
                    break
                # ...otherwise we're going to compare it
                # against all known objects. If there's
                # overlap we delete this and move on
                for other in self.goal:
                    other_id = self.goal[other].id
                    if self.check_collision(id, other_id):
                        collisions = True
                        break

                if collisions:
                    self.sim.physics_client.removeBody(id)
                    continue
                else:
                    break
            self.goal[object] = TargetObject(id, name, shape, size, position, color)
                
    def check_collision(self, object1: str, object2: str) -> bool:
        contacts = self.sim.physics_client.getContactPoints(object1, object2)
        return contacts is not None and len(contacts) > 0
    
    def delete_all_objects(self):
        for object in self.goal:
            self.sim.physics_client.removeBody(self.goal[object].id)
        self.goal = {}
    
    def _random_position(self):
        x = uniform(self.obj_range_low[0], self.obj_range_high[0])
        y = uniform(self.obj_range_low[1], self.obj_range_high[1])
        return np.array([x, y, 0.02])  # Z-position slightly above the table to prevent clipping

    #! 기본 씬
    def _create_scene(self):
        self.sim.create_table(length=1.1, width=0.7, height=0.4, x_offset=-0.3)

    #!리셋  
    def reset(self):
        self.set_sorter_positions()
        self.setup_target_objects()
        self.score = 0.0
        
    def get_obs(self):
        # First check for floor collisions. Remove any colliding objects.
        floor_id = self.sim._bodies_idx["plane"]
        for object_key in self.goal:
            if self.goal[object_key].removed:
                continue
            object_id = self.goal[object_key].id
            if self.check_collision(object_id, floor_id):
                self.score += FLOOR_PENALTY
                self.sim.physics_client.removeBody(object_id)
                self.goal[object_key].removed = True
        # Then check for collisions between the goals and a given target.
        # Remove any colliding targets.
        for object_key in self.goal:
            if self.goal[object_key].removed:
                continue
            for goal in GOALS:
                object = self.goal[object_key]
                object_id = object.id
                goal_id = self.sim._bodies_idx[goal]

                if self.check_collision(object_id, goal_id):
                    self.sim.physics_client.removeBody(object_id)
                    self.goal[object_key].removed = True

                    if CORRECT_SORTS[goal] == object.shape:
                        self.score += SORT_REWARD
                    else:
                        self.score += WRONG_SORT_REWARD
        # Ensure that each goal hasn't moved; this is a consequence of the
        # collision checking we do
        self.set_sorter_positions()
        
        return self._get_poses_output()
    
    def get_object_pose(self, object: TargetObject) -> np.array:
        object_position = self.sim.get_base_position(object.name)
        object_rotation = self.sim.get_base_rotation(object.name)
        object_velocity = self.sim.get_base_velocity(object.name)
        object_angular_velocity = self.sim.get_base_angular_velocity(object.name)
        observation = np.concatenate(
            [object_position, object_rotation, object_velocity, object_angular_velocity]
        )
        return observation.astype(np.float32)

    def _get_poses_output(self) -> np.array:
        """
        _get_poses_output will return the poses of all objects in the scene,
        as well as their identity and size. It will be a series of values for
        the raw (x, y, z, theta, phi, psi) pose of the object, as well as an
        identity (type of shape), and size (0-1) for min/max size, and the pose
        of the robot's end effector, and a 0-1 value for its gripper open/close
        state. An example of the return would be:

        [[x, y, z, theta, phi, psi,
          xd, yd, zd, thetad, phid, psid, <~ velocities
        [identity], [size]] (times # of set objects), ...,
        (ee_x, ee_y, ee_z, ee_theta, ee_phi, ee_psi,
        ee_xd, ee_yd, ee_zd, ee_thetad, ee_phid, ee_psid), # <~ velocities
        gripper_status]

        Note that the identity is a one-hot encoded list of shape [CUBE, CYLINDER,
        SPHERE] and that size is a three value array of varying meaning based
        on size: [x, y, z] for CUBE, [radius, height] for CYLINDER, [radius]
        for SPHERE. Unused values are 0.0.
        """
        # The size of this vector is determined by the number of objects expected
        pose_values = 12
        shape_values = 3
        size_values = 3
        # End effector values
        ee_values = 12
        finger_values = 1
        # The length of our vector is (pose_values + (identity, size)) for each
        # object, pose_values for the end effector, and one additional value for
        # the gripper finger state (distance between fingers)
        size = (
            (len(self.goal) * (pose_values + shape_values + size_values))
            + ee_values
            + finger_values
        )
        observation: np.array = np.zeros((size,), dtype="float32")

        index = 0
        for object in self.goal.values():
            # If the object has been removed, just report 0's for its existence
            if object.removed:
                index += 1
                continue

            pose = self.get_object_pose(object)
            object_index = index * (pose_values + shape_values + size_values)
            observation[object_index : object_index + pose_values] = pose

            # The shape is a one hot encoded vector of [CUBE, CYLINDER, SPHERE]
            if object.shape == CUBE:
                shape_type = [1, 0, 0]
            elif object.shape == CYLINDER:
                shape_type = [0, 1, 0]
            elif object.shape == SPHERE:
                shape_type = [0, 0, 1]
            shapes_index = object_index + pose_values
            observation[shapes_index : shapes_index + shape_values] = shape_type
            size_index = shapes_index + shape_values
            observation[size_index : size_index + size_values] = object.size
            index += 1

        # Get the end effector position
        ee_position = self.robot.get_ee_position()
        ee_rotation_quaternion = self.sim.get_link_orientation(
            self.robot.body_name, self.robot.ee_link
        )
        ee_rotation = self._quaternion_to_euler(ee_rotation_quaternion)
        # print("rot", ee_rotation)
        # print("rot other", self.sim.get_base_rotation(self.robot.ee_link))
        ee_velocity = self.robot.get_ee_velocity()
        ee_rotational_velocity = self.sim.get_link_angular_velocity(
            self.robot.body_name, self.robot.ee_link
        )

        # ee_angulary_velocity = 0.0
        fingers_width = self.robot.get_fingers_width()
        ee_index = (pose_values + shape_values + size_values) * len(self.goal)
        observation[ee_index : ee_index + 3] = ee_position
        observation[ee_index + 3 : ee_index + 6] = ee_rotation
        observation[ee_index + 6 : ee_index + 9] = ee_velocity
        observation[ee_index + 9 : ee_index + 12] = ee_rotational_velocity
        observation[ee_index + 12] = fingers_width

        return observation
    
    def _quaternion_to_euler(self, quaternion: np.array):
        """
        _quaternion_to_euler will convert a quaternion to euler angless
        """
        x, y, z, w = quaternion
        t0 = 2.0 * (w * x + y * z)
        t1 = 1.0 - 2.0 * (x * x + y * y)
        X = math.atan2(t0, t1)

        t2 = 2.0 * (w * y - z * x)
        t2 = 1.0 if t2 > +1.0 else t2
        t2 = -1.0 if t2 < -1.0 else t2
        Y = math.asin(t2)

        t3 = 2.0 * (w * z + x * y)
        t4 = 1.0 - 2.0 * (y * y + z * z)
        Z = math.atan2(t3, t4)

        return np.array([X, Y, Z]).astype(np.float32)
    
    def get_achieved_goal(self) -> np.ndarray:
        return np.array(
            all(target.removed for target in self.goal.values()), dtype="bool"
        )
    
    def is_terminated(self) -> bool:
        """
        is_terminated returns whether or not the episode is
        in a terminal state; this can be due to:
        1. All objects have been removed somehow from the env
        2. The timer has hit 0

        It is not an indication of success
        """

        return all(obj.removed for obj in self.goal.values())
    
    def is_success(self, achieved_goal: np.ndarray, desired_goal: np.ndarray, info: Dict[str, Any] = ...) -> np.ndarray:
        return np.array([self.is_terminated()], dtype="bool")
    
    def compute_reward(self, achieved_goal, desired_goal, info: Dict[str, Any] = ...)-> np.ndarray:
        return np.array([self.score], dtype="float32")
    
SORTING_ONE = "sorting_one"
SORTING_TWO = "sorting_two"
SORTING_THREE = "sorting_three"
GOALS = [SORTING_ONE, SORTING_TWO, SORTING_THREE]

CUBE = 0
CYLINDER = 1
SPHERE = 2
SHAPES = [CUBE, CYLINDER, SPHERE]

# This is the expected correct sorting results
CORRECT_SORTS = {
    SORTING_ONE: CYLINDER,
    SORTING_TWO: SPHERE,
    SORTING_THREE: CUBE,
}

STEP_PENALTY = -1
FLOOR_PENALTY = -50
WRONG_SORT_REWARD = 200
SORT_REWARD = 500