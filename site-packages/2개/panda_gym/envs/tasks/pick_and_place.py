# #!Sparse
# from typing import Any, Dict
# import numpy as np
# from random import uniform
# from panda_gym.envs.core import Task
# from panda_gym.pybullet import PyBullet
# from panda_gym.utils import distance

# class PickAndPlace(Task):
#     def __init__(
#         self,
#         sim: PyBullet,
#         num_objects: int = 3,
#         reward_type: str = "sparse",
#         distance_threshold: float = 0.1,
#         obj_x_range: float = 0.3,
#         obj_y_range: float = 0.5,
#     ):
#         super().__init__(sim)
#         self.num_objects = num_objects
#         self.reward_type = reward_type
#         self.distance_threshold = distance_threshold
#         self.obj_x_range = obj_x_range
#         self.obj_y_range = obj_y_range
#         self.obj_range_low = np.array([-obj_x_range / 2, -obj_y_range / 2, 0])
#         self.obj_range_high = np.array([obj_x_range / 2-0.1, obj_y_range / 2, 0])
#         self.object_size = 0.04
#         self.objects = []
#         self.object_colors = [
#             np.array([1.0, 0.0, 0.0, 1.0]),  # 빨강 (박스)
#             np.array([0.0, 0.0, 1.0, 1.0]),  # 파랑 (실린더)
#             np.array([0.0, 1.0, 0.0, 1.0])  # 초록 (스피어)
#         ]# 각 물체의 색상
#         self.object_shapes = ["box", "cylinder", "sphere"]
#         self.goal_positions = [
#             np.array([0.13, -0.2, 0.01]),
#             np.array([0.13, 0, 0.01]),
#             np.array([0.13, 0.2, 0.01])
#         ]# 고정된 목표 위치
#         self.goal_colors = [
#             np.array([1.0, 0.0, 0.0, 0.4]),  # 빨강
#             np.array([0.0, 0.0, 1.0, 0.4]),  # 파랑
#             np.array([0.0, 1.0, 0.0, 0.4])  # 초록
#         ]# 각 목표의 색상
#         with self.sim.no_rendering():
#             self._create_scene()

#     def _create_scene(self):
#         """Create the scene."""
#         self.sim.create_plane(z_offset=-0.4)
#         self.sim.create_table(length=1.1, width=0.7, height=0.4, x_offset=-0.3)
#         for i in range(self.num_objects):
#             # 물체 박스 생성
#             obj_name = f"object_{i}"
#             shape = self.object_shapes[i]
#             obj_position = self._random_position()
#             while self._check_overlap(obj_position, self.object_size):
#                 obj_position = self._random_position()
#             if shape == "box":
#                 self.sim.create_box(
#                     body_name=obj_name,
#                     half_extents=np.ones(3) * self.object_size / 2,
#                     mass=1.0,
#                     position=obj_position,
#                     rgba_color= self.object_colors[i]
#                 )
#             elif shape == "cylinder":
#                 self.sim.create_cylinder(
#                     body_name=obj_name,
#                     radius= self.object_size/1.5, 
#                     height=self.object_size/1.5, 
#                     mass=1.0,
#                     position=obj_position, 
#                     rgba_color= self.object_colors[i]
#                 )
#             elif shape == "sphere":
#                 self.sim.create_sphere(
#                     body_name=obj_name, 
#                     radius= self.object_size/1.5,
#                     mass=1.0, 
#                     position=obj_position,
#                     rgba_color= self.object_colors[i]
#                 )
#             self.objects.append(obj_name)
#             # 목표 박스 생성
#             target_name = f"target_{i}"
#             self.sim.create_box(
#                 body_name = target_name,
#                 half_extents = np.ones(3) * self.object_size / 2,
#                 mass = 0.0,
#                 ghost = True,
#                 position = self.goal_positions[i],
#                 rgba_color = self.goal_colors[i]
#             )
#         # Visualize the object range with a transparent box
#         # self.sim.create_box(
#         #     body_name="range_visualization",
#         #     half_extents=[self.obj_x_range / 2, self.obj_y_range / 2, 0.01],  # very thin box
#         #     mass=0.0,
#         #     position=[0, 0, 0.005],  # slightly above the plane to make it visible
#         #     rgba_color=[0, 1, 1, 0.3],  # cyan and semi-transparent
#         #     ghost=True 
#         # )
#         # self.sim.create_box(
#         #         body_name="blocker1",
#         #         half_extents=np.array([0.01, 0.3, 0.005]),
#         #         mass=0.0,
#         #         ghost=False,
#         #         position=self.sorter_positions["blocker"],
#         #         rgba_color=np.array([0.0, 0.0, 0.0, 0.8]),
#         #     )
        
#     def _check_overlap(self, position, size):
#         for obj in self.objects:
#             obj_position = self.sim.get_base_position(obj)
#             if np.linalg.norm(position - obj_position) < np.sum(size):
#                 return True
#         return False

#     def get_obs(self):
#         object_0_position = np.array(self.sim.get_base_position("object_0"))
#         object_0_rotation = np.array(self.sim.get_base_rotation("object_0"))
#         object_0_velocity = np.array(self.sim.get_base_velocity("object_0"))
#         object_0_angular_velocity = np.array(self.sim.get_base_angular_velocity("object_0"))
#         object_1_position = np.array(self.sim.get_base_position("object_1"))
#         object_1_rotation = np.array(self.sim.get_base_rotation("object_1"))
#         object_1_velocity = np.array(self.sim.get_base_velocity("object_1"))
#         object_1_angular_velocity = np.array(self.sim.get_base_angular_velocity("object_1"))
#         object_2_position = np.array(self.sim.get_base_position("object_2"))
#         object_2_rotation = np.array(self.sim.get_base_rotation("object_2"))
#         object_2_velocity = np.array(self.sim.get_base_velocity("object_2"))
#         object_2_angular_velocity = np.array(self.sim.get_base_angular_velocity("object_2"))
#         observation = np.concatenate(
#             [
#                 object_0_position,
#                 object_0_rotation,
#                 object_0_velocity,
#                 object_0_angular_velocity,
#                 object_1_position,
#                 object_1_rotation,
#                 object_1_velocity,
#                 object_1_angular_velocity,
#                 object_2_position,
#                 object_2_rotation,
#                 object_2_velocity,
#                 object_2_angular_velocity,
#             ]
#         )
#         return observation

#     def get_achieved_goal(self):
#         object0_position = np.array(self.sim.get_base_position("object_0"))
#         object1_position = np.array(self.sim.get_base_position("object_1"))
#         object2_position = np.array(self.sim.get_base_position("object_2"))
#         achieved_goal = np.concatenate((object0_position, object1_position, object2_position))
#         return achieved_goal
    
#     def get_goal(self):
#         target0_position = np.array(self.sim.get_base_position("target_0"))
#         target1_position = np.array(self.sim.get_base_position("target_1"))
#         target2_position = np.array(self.sim.get_base_position("target_2"))
#         goal = np.concatenate((target0_position, target1_position, target2_position))
#         return goal
    
#     def reset(self):
#         with self.sim.no_rendering():
#             for i, obj_name in enumerate(self.objects):
#                 obj_pos = self._random_position()
#                 while self._check_overlap(obj_pos, self.object_size):
#                     obj_pos = self._random_position()
#                 self.sim.set_base_pose(obj_name, obj_pos, [0, 0, 0, 1])
                
#         self.sim.set_base_pose("target_0", self.goal_positions[0], np.array([0.0, 0.0, 0.0, 1.0]))
#         self.sim.set_base_pose("target_1", self.goal_positions[1], np.array([0.0, 0.0, 0.0, 1.0]))
#         self.sim.set_base_pose("target_2", self.goal_positions[2], np.array([0.0, 0.0, 0.0, 1.0]))

#     def _random_position(self):
#         x = uniform(self.obj_range_low[0], self.obj_range_high[0])
#         y = uniform(self.obj_range_low[1], self.obj_range_high[1])
#         return np.array([x, y, self.object_size / 2])  # Z-position slightly above the table to prevent clipping

#     def is_success(self, achieved_goal, desired_goal, info: Dict[str, Any] = ...)-> np.ndarray:
#         d = distance(achieved_goal, desired_goal)
#         return np.array((d < self.distance_threshold), dtype=bool)

#     def compute_reward(self, achieved_goal, desired_goal, info: Dict[str, Any] = ...)-> np.ndarray:
#         d = distance(achieved_goal, desired_goal)
#         if self.reward_type == "sparse":
#             return -np.array((d > self.distance_threshold), dtype=np.float32)
#         else:
#             return -d.astype(np.float32)

# !한곳에 모으기
from typing import Any, Dict
import numpy as np
from random import uniform
from panda_gym.envs.core import Task
from panda_gym.pybullet import PyBullet
from panda_gym.utils import distance

class PickAndPlace(Task):
    def __init__(
        self,
        sim: PyBullet,
        num_objects: int = 2,
        reward_type: str = "sparse",
        distance_threshold: float = 0.1,
        obj_x_range: float = 0.3,
        obj_y_range: float = 0.5,
    ):
        super().__init__(sim)
        self.num_objects = num_objects
        self.reward_type = reward_type
        self.distance_threshold = distance_threshold
        self.obj_x_range = obj_x_range
        self.obj_y_range = obj_y_range
        self.obj_range_low = np.array([-obj_x_range / 2, -obj_y_range / 2, 0]) 
        self.obj_range_high = np.array([obj_x_range / 2 -0.2, obj_y_range / 2, 0])
        self.object_size = 0.04
        self.objects = []
        self.object_colors = [
            np.array([1.0, 0.0, 0.0, 1.0]),  # 빨강 (박스)
            np.array([0.0, 0.0, 1.0, 1.0]),  # 파랑 (실린더)
            np.array([0.0, 1.0, 0.0, 1.0])  # 초록 (스피어)
        ]# 각 물체의 색상
        self.object_shapes = ["box", "cylinder", "sphere"]
        self.target_position = np.array([0.11, 0, 0])
        self.blocker_positions = [
            np.array([0.11, -0.115, 0]),
            np.array([0.18, 0, 0]),
            np.array([0.11, 0.115, 0])
        ]
        self.blocker_size =[
            np.array([0.08, 0.01, 0.025]),
            np.array([0.01, 0.10, 0.025]),
            np.array([0.08, 0.01, 0.025])
        ]
        with self.sim.no_rendering():
            self._create_scene()

    def _create_scene(self):
        """Create the scene."""
        self.sim.create_plane(z_offset=-0.4)
        self.sim.create_table(length=1.1, width=0.7, height=0.4, x_offset=-0.3)
        for i in range(self.num_objects):
            # 물체 박스 생성
            obj_name = f"object_{i}"
            shape = self.object_shapes[i]
            obj_position = self._random_position()
            while self._check_overlap(obj_position, self.object_size):
                obj_position = self._random_position()
            if shape == "box":
                self.sim.create_box(
                    body_name=obj_name,
                    half_extents=np.ones(3) * self.object_size / 2,
                    mass=1.0,
                    position=obj_position,
                    rgba_color= self.object_colors[i]
                )
            elif shape == "cylinder":
                self.sim.create_cylinder(
                    body_name=obj_name,
                    radius= self.object_size/1.5, 
                    height=self.object_size/1.5, 
                    mass=1.0,
                    position=obj_position, 
                    rgba_color= self.object_colors[i]
                )
            elif shape == "sphere":
                self.sim.create_sphere(
                    body_name=obj_name, 
                    radius= self.object_size/1.5,
                    mass=1.0, 
                    position=obj_position,
                    rgba_color= self.object_colors[i]
                )
            self.objects.append(obj_name)
            # 목표 박스 생성
            target_name = f"target_{i}"
            self.sim.create_cylinder(
                body_name = target_name,
                radius= 0.09, 
                height= 0.02,
                mass = 0.0,
                ghost = True,
                position = self.target_position,
                rgba_color = [0, 1, 1, 0.3] # cyan
            )
        for i in range(3):
            # 벽
            self.sim.create_box(
                body_name=f"blocker_{i}",
                half_extents=self.blocker_size[i],
                mass= 10000.0,
                ghost=False,
                position= self.blocker_positions[i],
                rgba_color=np.array([0.0, 0.0, 0.0, 1.0]),
            )
        
    def _check_overlap(self, position, size):
        for obj in self.objects:
            obj_position = self.sim.get_base_position(obj)
            if np.linalg.norm(position - obj_position) < np.sum(size):
                return True
        return False

    def get_obs(self):
        object_0_position = np.array(self.sim.get_base_position("object_0"))
        object_0_rotation = np.array(self.sim.get_base_rotation("object_0"))
        object_0_velocity = np.array(self.sim.get_base_velocity("object_0"))
        object_0_angular_velocity = np.array(self.sim.get_base_angular_velocity("object_0"))
        object_1_position = np.array(self.sim.get_base_position("object_1"))
        object_1_rotation = np.array(self.sim.get_base_rotation("object_1"))
        object_1_velocity = np.array(self.sim.get_base_velocity("object_1"))
        object_1_angular_velocity = np.array(self.sim.get_base_angular_velocity("object_1"))
        observation = np.concatenate(
            [
                object_0_position,
                object_0_rotation,
                object_0_velocity,
                object_0_angular_velocity,
                object_1_position,
                object_1_rotation,
                object_1_velocity,
                object_1_angular_velocity,
            ]
        )
        return observation

    def get_achieved_goal(self):
        object0_position = np.array(self.sim.get_base_position("object_0"))
        object1_position = np.array(self.sim.get_base_position("object_1"))
        achieved_goal = np.concatenate((object0_position, object1_position))
        return achieved_goal
    
    def get_goal(self):
        target0_position = np.array(self.sim.get_base_position("target_0"))
        target1_position = np.array(self.sim.get_base_position("target_1"))
        goal = np.concatenate((target0_position, target1_position))
        return goal
    
    def reset(self):
        with self.sim.no_rendering():
            for i, obj_name in enumerate(self.objects):
                obj_pos = self._random_position()
                while self._check_overlap(obj_pos, self.object_size):
                    obj_pos = self._random_position()
                self.sim.set_base_pose(obj_name, obj_pos, [0, 0, 0, 1])
                
        self.sim.set_base_pose("target_0", self.target_position, np.array([0.0, 0.0, 0.0, 1.0]))
        self.sim.set_base_pose("target_1", self.target_position, np.array([0.0, 0.0, 0.0, 1.0]))

    def _random_position(self):
        x = uniform(self.obj_range_low[0], self.obj_range_high[0])
        y = uniform(self.obj_range_low[1], self.obj_range_high[1])
        return np.array([x, y, self.object_size / 2])  # Z-position slightly above the table to prevent clipping

    def is_success(self, achieved_goal, desired_goal, info: Dict[str, Any] = ...)-> np.ndarray:
        d = distance(achieved_goal, desired_goal)
        return np.array((d < self.distance_threshold*2), dtype=bool)

    def compute_reward(self, achieved_goal, desired_goal, info: Dict[str, Any] = ...)-> np.ndarray:
        if self.reward_type == "sparse":
            d = distance(achieved_goal, desired_goal)
            return -np.array((d > self.distance_threshold*2), dtype=np.float32)
        else:
            reward = 0
            if(len(achieved_goal) // 3 == self.num_objects):
                for i in range(len(achieved_goal) // 3):
                    d = distance(achieved_goal[i*3:(i+1)*3], desired_goal[i*3:(i+1)*3])
                    if d <= self.distance_threshold:
                        reward += 0.2
                    reward += d
            else:
                reward = distance(achieved_goal, desired_goal)
            return -reward.astype(np.float32)
        
# #!Dense 고정
# from typing import Any, Dict
# import numpy as np
# from random import uniform
# from panda_gym.envs.core import Task
# from panda_gym.pybullet import PyBullet
# from panda_gym.utils import distance

# class PickAndPlace(Task):
#     def __init__(
#         self,
#         sim: PyBullet,
#         num_objects: int = 3,
#         reward_type: str = "dense",
#         distance_threshold: float = 0.07,
#         obj_x_range: float = 0.2,
#         obj_y_range: float = 0.6,
#     ):
#         super().__init__(sim)
#         self.num_objects = num_objects
#         self.reward_type = reward_type
#         self.distance_threshold = distance_threshold
#         self.obj_x_range = obj_x_range
#         self.obj_y_range = obj_y_range
#         self.obj_range_low = np.array([-obj_x_range / 2, -obj_y_range / 2, 0])
#         self.obj_range_high = np.array([obj_x_range / 2, obj_y_range / 2, 0])
#         # self.goal = None
#         self.fixed_size = np.array([0.04, 0.04, 0.04])
#         self.object_colors = [
#             np.array([1.0, 0.0, 0.0, 1.0]),  # 빨강 (박스)
#             np.array([0.0, 0.0, 1.0, 1.0]),  # 파랑 (실린더)
#             np.array([0.0, 1.0, 0.0, 1.0])  # 초록 (스피어)
#         ]# 각 물체의 색상
#         self.object_shapes = ["box", "cylinder", "sphere"]
#         self.object_positions = [
#             np.array([-0.1, 0.2, 0.01]),
#             np.array([-0.1, -0.2, 0.01]),
#             np.array([-0.1, 0, 0.01])
#         ]# 고정된 물체
#         self.goal_positions = [
#             np.array([0.18, -0.2, 0.01]),
#             np.array([0.18, 0, 0.01]),
#             np.array([0.18, 0.2, 0.01])
#         ]# 고정된 목표 위치
#         self.goal_colors = [
#             np.array([1.0, 0.0, 0.0, 0.4]),  # 빨강
#             np.array([0.0, 0.0, 1.0, 0.4]),  # 파랑
#             np.array([0.0, 1.0, 0.0, 0.4])  # 초록
#         ]# 각 목표의 색상
#         self.goal_size = np.array([0.04, 0.04, 0.01])# 목표의 크기
#         with self.sim.no_rendering():
#             self._create_scene()

#     def _create_scene(self):
#         """Create the scene."""
#         self.sim.create_plane(z_offset=-0.4)
#         self.sim.create_table(length=1.1, width=0.7, height=0.4, x_offset=-0.3)
#         self.objects = []
#         self.targets = []
#         for i in range(self.num_objects):
#             # 물체 생성
#             obj_name = f"object_{i}"
#             color = self.object_colors[i]
#             shape_choice = self.object_shapes[i]
#             obj_pos = self.object_positions[i]
#             # obj_pos = self._random_position()
#             # while self._check_overlap(obj_pos, self.fixed_size):
#             #     obj_pos = self._random_position()
#             self._create_object(shape_choice, self.fixed_size, obj_pos, color, obj_name)
#             # 목표 위치 박스 생성
#             target_name = f"target_{i}"
#             self.sim.create_box(
#                 body_name=target_name,
#                 half_extents=self.goal_size,
#                 mass=0.0,
#                 ghost=True,
#                 position=self.goal_positions[i],
#                 rgba_color=self.goal_colors[i]
#             )
#             self.targets.append(target_name)
#         # Visualize the object range with a transparent box
#         # self.sim.create_box(
#         #     body_name="range_visualization",
#         #     half_extents=[self.obj_x_range / 2, self.obj_y_range / 2, 0.01],  # very thin box
#         #     mass=0.0,
#         #     position=[0, 0, 0.005],  # slightly above the plane to make it visible
#         #     rgba_color=[0, 1, 1, 0.3],  # cyan and semi-transparent
#         #     ghost=True 
#         # )
        
#     def _check_overlap(self, position, size):
#         for obj in self.objects:
#             obj_position = self.sim.get_base_position(obj)
#             if np.linalg.norm(position - obj_position) < np.sum(size):
#                 return True
#         return False

#     def _create_object(self, shape, size, position, color, name):
#         if shape == "box":
#             self.sim.create_box(body_name=name, half_extents=size / 2, mass=1.0, position=position, rgba_color=color)
#         elif shape == "cylinder":
#             self.sim.create_cylinder(body_name=name, radius=size[0] / 1.5, height=size[1], mass=1.0, position=position, rgba_color=color)
#         elif shape == "sphere":
#             self.sim.create_sphere(body_name=name, radius=size[0] / 1.5, mass=1.0, position=position, rgba_color=color)
#         self.objects.append(name)


#     def get_obs(self):
#         object_0_position = np.array(self.sim.get_base_position("object_0"))
#         object_0_rotation = np.array(self.sim.get_base_rotation("object_0"))
#         object_0_velocity = np.array(self.sim.get_base_velocity("object_0"))
#         object_0_angular_velocity = np.array(self.sim.get_base_angular_velocity("object_0"))
#         object_1_position = np.array(self.sim.get_base_position("object_1"))
#         object_1_rotation = np.array(self.sim.get_base_rotation("object_1"))
#         object_1_velocity = np.array(self.sim.get_base_velocity("object_1"))
#         object_1_angular_velocity = np.array(self.sim.get_base_angular_velocity("object_1"))
#         object_2_position = np.array(self.sim.get_base_position("object_2"))
#         object_2_rotation = np.array(self.sim.get_base_rotation("object_2"))
#         object_2_velocity = np.array(self.sim.get_base_velocity("object_2"))
#         object_2_angular_velocity = np.array(self.sim.get_base_angular_velocity("object_2"))
#         observation = np.concatenate(
#             [
#                 object_0_position,
#                 object_0_rotation,
#                 object_0_velocity,
#                 object_0_angular_velocity,
#                 object_1_position,
#                 object_1_rotation,
#                 object_1_velocity,
#                 object_1_angular_velocity,
#                 object_2_position,
#                 object_2_rotation,
#                 object_2_velocity,
#                 object_2_angular_velocity,
#             ]
#         )
#         return observation

#     def get_achieved_goal(self):
#         object0_position = np.array(self.sim.get_base_position("object_0"))
#         object1_position = np.array(self.sim.get_base_position("object_1"))
#         object2_position = np.array(self.sim.get_base_position("object_2"))
#         object_position = np.concatenate(
#             [
#                 object0_position, 
#                 object1_position,
#                 object2_position
#             ]
#         )
#         return object_position
    
#     def get_goal(self):
#         target0_position = np.array(self.sim.get_base_position("target_0"))
#         target1_position = np.array(self.sim.get_base_position("target_1"))
#         target2_position = np.array(self.sim.get_base_position("target_2"))
#         goals = np.concatenate(
#             [
#                 target0_position,
#                 target1_position,
#                 target2_position
#             ]
#         )
#         return goals
    
#     def reset(self):
#         with self.sim.no_rendering():
#             for i, obj_name in enumerate(self.objects):
#                 obj_pos = self.object_positions[i]
#                 # obj_pos = self._random_position()
#                 # while self._check_overlap(obj_pos, self.fixed_size):
#                     # obj_pos = self._random_position()
#                 self.sim.set_base_pose(obj_name, obj_pos, [0, 0, 0, 1])

#             # for i, target_name in enumerate(self.targets):
#             #     goal_pos = self.goal_positions[i]
#             #     self.sim.set_base_pose(target_name, goal_pos, [0, 0, 0, 1])

#             # self.goal = np.array([self.sim.get_base_position(t) for t in self.targets])

#     def _random_position(self):
#         x = uniform(self.obj_range_low[0], self.obj_range_high[0])
#         y = uniform(self.obj_range_low[1], self.obj_range_high[1])
#         return np.array([x, y, 0.02])  # Z-position slightly above the table to prevent clipping

#     def is_success(self, achieved_goal, desired_goal, info: Dict[str, Any] = ...)-> np.ndarray:
#         d = distance(achieved_goal, desired_goal)
#         return np.array((d < self.distance_threshold), dtype=bool)

#     def compute_reward(self, achieved_goal, desired_goal, info: Dict[str, Any] = ...)-> np.ndarray:
#         d = distance(achieved_goal, desired_goal)
#         if self.reward_type == "sparse":
#             return -np.array((d > self.distance_threshold), dtype=np.float32)
#         else:
#             return -d.astype(np.float32)
